package application.server;

import global.models.*;

import java.util.ArrayList;

/***
 * The Game class holds the game logic. Movement, bomb behavior, etc are implemented in this class. Its defines how its done.
 */
class Game {

    /*----------------------------- Members -----------------------------*/

    // Playground tiles are tiles which are generated by a template file.
	private Tile[][] playground;
	// While, the delta holds any tiles that changed its stats. The delta list gets send to the clients and then flushed every once in a while,
    private ArrayList<Tile> delta;
    // The players are worth an own list because their stats are more often needed.
    private ArrayList<Player> players;

    private int playgroundColumnSize = 0;
    private int playgroundRowSize = 0;

	/*----------------------------- Constructor -----------------------------*/
	Game(){
        this.delta = new ArrayList<>();
		this.players = new ArrayList<>();
	}

    /*----------------------------- Getter and Setter -----------------------------*/

    /**
     * @return The width of the playground as an index value.
     */
    int getPlaygroundColumnSize(){
        return playgroundColumnSize;
    }

    /**
     * @return The height of the playground as an index value.
     */
    int getPlaygroundRowSize(){
        return playgroundRowSize;
    }

    /**
     * @return A list holding every changed tile.
     */
    ArrayList<Tile> getDelta() {
        return delta;
    }

    /**
     * @return The current players as array.
     */
    Player[] getPlayerArray(){
        return players.toArray(new Player[0]);
    }

    /**
     * @return The last living player.
     */
    Player getLastManStanding(){
        for(Player player: players){
            if(player.isAlive()){
                player.Score();
                return player;
            }
        }
        return null;
    }

    /**
     * Counts the players alive.
     * @return The amount of living player.
     */
    int getHowManyPlayersAreAlive(){
        int counter = 0;
        for(Player player: players){
            if(player.isAlive()){ counter++; }
        }
        return counter;
    }

    /*----------------------------- Private Methods -----------------------------*/

    /**
     * Little helper to update the tile delta list. Prevents updating the same tile more than once per cycle.
     * @param tile Tile object containing changes.
     */
    private void updateDelta(Tile tile){
        if(delta.contains(tile)){return;}
        delta.add(tile);
    }

    /**
     * Is responsible for destroying objects around a detonation. By design, the destruction radius is 1 up, down, left and right.
     * @param pos Position of the explosions center.
     */
    private void destroyObjects(Position pos){
        // Check for every direction, if its nearby the game border. Then just do nothing.
        if(pos.vertical-1 >= 0){
            destroyObject(pos.vertical-1, pos.horizontal);
        }
        if(pos.vertical+1 <= playgroundRowSize-1){
            destroyObject(pos.vertical+1, pos.horizontal);
        }
        if(pos.horizontal-1 >= 0){
            destroyObject(pos.vertical, pos.horizontal-1);
        }
        if(pos.horizontal+1 <= playgroundColumnSize-1){
            destroyObject(pos.vertical, pos.horizontal+1);
        }
    }

    /**
     * This method destroys a particular tile. This means almost every time to replace the current tile with an empty tile.
     * Through the position parameter the method knows which tiles to destroy.
     * @param vertical The vertical position index from the tile to destroy.
     * @param horizontal The horizontal position index from the tile to destroy.
     */
    private void destroyObject(int vertical, int horizontal) {
        Tile tileToDestroy = playground[vertical][horizontal];
        Player player = getPlayerOnPosition(vertical, horizontal);
        if (tileToDestroy instanceof DestroyableWall) {
            ((DestroyableWall) tileToDestroy).Destroy();
            replaceWithNew(tileToDestroy);
        }
        if (tileToDestroy instanceof Bomb) {
            bombExplode((Bomb) tileToDestroy);
            replaceWithNew(tileToDestroy);
        }
        if (player != null) {
            player.Die();
            updateDelta(player);
        }
    }

    private Player getPlayerOnPosition(int vertical, int horizontal){
        for(Player p: players){
            if(p.getPosition().vertical == vertical && p.getPosition().horizontal == horizontal){
                return p;
            }
        }
        return null;
    }

    /**
     * Takes care of creating a new tile and replace the given tile.
     * @param tile Gets replaced by a new empty tile.
     */
    private void replaceWithNew(Tile tile){
        Tile tmp = new Tile(tile.getPosition().horizontal, tile.getPosition().vertical);
        playground[tile.getPosition().vertical][tile.getPosition().horizontal] = tmp;
        updateDelta(tmp);
        updateDelta(tile);
    }

    /**
     * The collision detection for the player movement. For every move from tile to tile, the method check if the
     * tile ahead of the player in the moving direction, is passable or not.
     * Returns true if the player crashes into a uncrossable tile.
     * @param pos Player position before moving.
     * @param movingDirection The Direction in which the player moves.
     * @return True if the player will intersect with an uncrossable object.
     */
    private boolean playerIntersect(Position pos, Direction movingDirection){
        Tile tile = null;
        switch (movingDirection){
            case UP:
                if(pos.vertical-1 < 0){return true;}
                tile = playground[pos.vertical-1][pos.horizontal];
                break;
            case DOWN:
                if(pos.vertical+1 > playgroundRowSize){return true;}
                tile = playground[pos.vertical+1][pos.horizontal];
                break;
            case RIGHT:
                if(pos.horizontal+1 > playgroundColumnSize) {return true;}
                tile = playground[pos.vertical][pos.horizontal+1];
                break;
            case LEFT:
                if(pos.horizontal-1 < 0) {return true;}
                tile = playground[pos.vertical][pos.horizontal-1];
        }

        return (tile instanceof Bomb || tile instanceof Wall || tile instanceof DestroyableWall);
    }

    /*----------------------------- Public Methods -----------------------------*/

    /***
     * Does what it does.
     */
    void clearDelta(){
	    delta.clear();
    }

    /***
     * Returns the current amount of joined players.
     * @return The amount of joined players.
     */
    int getPlayerCount(){
        return players.size();
    }

	/**
	 * Create a new playground based on a csv file, which acts as blueprint for building the battlefield.
	 */
    void createPlayground(){
        ArrayList<ArrayList<String>> blueprint = CSVReader.GetPlaygroundBlueprint();

        // Store the size of the playground and initialize a tile array to generate the playground tiles.
		playgroundRowSize = blueprint.size();
		playgroundColumnSize = blueprint.get(0).size();
		playground = new Tile[playgroundRowSize][playgroundColumnSize];

		// Iterate through both dimensions from the blueprint and generate tiles, based on the characters inside the fields.
		for(int r = 0; r < blueprint.size(); r++){
		    ArrayList<String> localRow = blueprint.get(r);
            Tile[] playgroundRow = new Tile[playgroundColumnSize];
            for(int i = 0; i < localRow.size(); i++) {
                switch (localRow.get(i)) {
                    case "o":
                        Tile tile = new Tile(i, r);
                        playgroundRow[i] = tile;
                        break;
                    case "w":
                        Wall wall = new Wall(i, r);
                        playgroundRow[i] = wall;
                        break;
                    case "x":
                        DestroyableWall dWall = new DestroyableWall(i, r);
                        playgroundRow[i] = dWall;
                        break;
                }
            }
            playground[r] = playgroundRow;
        }
	}

    /**
     * Adds a new player to the game. Returns 0 if the gamer already joined.
     * Otherwise it returns the amount of player joined.
     * @param playerName The new joined Player.
     * @return The current amount of joined player or 0 if the player couldn't be added.
     */
	int gamerJoin(String playerName){
        for(Player p: players){
            if(p.getName().equals(playerName)){
                return 0;
            }
        }

        Player player = null;
		if(players.size() == 0){
            player = new Player(playerName, getPlayerCount(), 0, 0);
		} else if(players.size() == 1){
            player = new Player(playerName, getPlayerCount(), playground[0].length-1, 0);
		} else if (players.size() == 2) {
            player = new Player(playerName, getPlayerCount(), 0, playground.length-1);
		} else if(players.size() == 3){
            player = new Player(playerName, getPlayerCount(), playground[0].length-1, playground.length-1);
		}

		players.add(player);
		updateDelta(player);

		return getPlayerCount();
	}

    /**
     * Returns the current playground tiles
     * @return Two dimensional tile array.
     */
	Tile[][] getPlayground(){
		return this.playground;
	}

    /**
     * Moves a particular player in the given direction. For each call, the player moves by one tile.
     * @param playerName To identify which player must be moved.
     * @param movingDirection The direction of movement.
     */
    void movePlayer(String playerName, Direction movingDirection){
        // Iterate through the player to find the right one to move.
        for(Player p : players){
            if(p.getName().equals(playerName)){
                // Only move the player once per game update.
                // If he is already moving, ignore the PlayerMoveMessage.
                if(p.isPlayerMoveing()){ return; }
                // Check if the way is free to move.
                if(playerIntersect(p.getPosition(), movingDirection)){ return; }

                // At this point everything is fine for the move.
                p.move(movingDirection);

                // Update the state of the player inside the list.
                int playerIndex = players.indexOf(p);
                players.set(playerIndex, p);

                // store the new player state to the tile delta list.
                updateDelta(p);

                return;
            }
        }
    }

    /**
     * Place a bomb on the battle field.
     * @param bomb The bomb to place.
     */
    void placeBomb(Bomb bomb){
        updateDelta(bomb);
    }

    /**
     * Handles the explosion of a bomb.
     * @param bomb Exploding bomb.
     */
    void bombExplode(Bomb bomb){
        // First destroy destroyable objects around the bomb.
        destroyObjects(bomb.getPosition());
        // notify the clients, that a bomb explodes.
        updateDelta(bomb);
    }

    void resetPlayerMotion(){
        for(Player p: players){
            p.setPlayerMoving(false);
        }
    }
}
